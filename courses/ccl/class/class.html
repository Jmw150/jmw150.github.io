
<!DOCTYPE html PUBLIC "-//w3c//dtd html 5.0 transitional//en">
<html>
 <head>
   <meta name="viewport" content="width=device-width">
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Jordan Winkler</title>
   <link rel="stylesheet" type="text/css" href="../../../bluewhite.css">
 </head>

<body>
 <div id="nav_bar">
  <div id="nav_bar_ul">
   <div id="nav_bar_li">
    <div id="nav_bar_li_a">
     <a href="../../../index.html">Home</a>
    </div>
   </div>
   <div id="nav_bar_li">
    <div id="nav_bar_li_a">
     <a href="../../../research/research.html">Research</a>
    </div>
   </div>
   <div id="nav_bar_li">
    <div id="nav_bar_li_a">
     <a href="../../../courses/courses.html">Courses</a>
    </div>
   </div>
  </div>
 </div>
<div id="content">
<h2>Course Notes</h2>

<b>Scrolls</b><br>
1. 	  Why Study Computability, Complexity, and Languages?<br><br>
- This section is on motivating topics of the course. It is easy to sell me on
  most of his points, as I do not find being well-read to be a major crime
  against professional productivity.<br><br>
2. 	  Sets, Tuples, Cartesian Products, Partial and Total Functions,
  Predicates, Quantifiers, Proofs   <br><br>
- Beautiful stuff. The notation for first order logic is the familiar stuff
  from first semester Mendelson.  <br><br>
PART 1:   Computability<br><br>
3. 	  The Minimalist (but all powerful) Programming Language  S<br><br>
- Yeah, the three instructions are basically peano axioms. Any integer is reachable via this inference set.<br><br>
<b>Questions</b><br>
- computability limitations versus type theory lack of limitations. (probably representation misnomer) <br>
- Robot intelligence will not exceed human intelligence?<br><br>
Off of the top of my head, the last is a weak argument on 2 accounts: <br>
(1.) Finite navigation over large infinite terrain is physical about the terrain,
not the navigation method. Ex. Having a library on methods versus inventing
from scratch. Deep learning is this on inherent topological structures in
reality.<br><br>
(2.) Computable is smaller than representable. Infinite structures can be described
and manipulated concretely with finite descriptions and morphisms. There are
limits to representation as well. But this is an argument against Turing
machines as a limitation on computation.  <br><br>
4. 	  Partially Computable Functions<br><br>
5. 	  Primitive Recursive Functions<br><br>
6. 	  Sixteen Building-Block PRC Functions<br><br>
7. 	  The Pairing Function and The Godel Numbers<br><br>
8. 	  Church's Thesis and the Unsolvability of the Halting Problem<br><br>
9. 	  A Universal Program that can Execute Any Program and the Concept of Recursive Enumerability<br><br>
10. 	  Calculations on Strings, and the Minimalist (but all powerful) Language Sn for String Processing<br><br>
11. 	  The Post-Turing Language T for String Processing and the Equivalence of S, Sn, and T<br><br>
12. 	  Turing Machines<br><br>
13. 	  What's Meant by a Turing Machine Accepting a Language <br><br>
PART 2:   Grammars and Automata <br><br>
14. 	  String Computations with Productions and Processes<br><br>
15. 	  Post's Correspondence Problem and Grammars<br><br>
16. 	  Phrase Structure Grammars and Context Sensitive Grammars<br><br>
17. 	  Finite Automata and Regular Languages<br><br>
18. 	  Properties of Regular Languages<br><br>
19. 	  Regular Expressions and the Pumping Lemma<br><br>
20. 	  Context-Free Languages   <br><br>
21. 	  Regular Grammars, Chomsky Normal Form, and Bar-Hillel's Pumping Lemma   <br><br>
22. 	  Properties of Context-Free Languages<br><br>
23. 	  Bracket Languages and the Pushdown Automata<br><br>
PART 3:   The Theory of NP-Completeness<br><br>
24. 	  Computational Complexity: Some Basic Definitions<br><br>
25. 	  Defining P and NP<br><br>
26. 	  A More Formal Definition of Class NP<br><br>
27. 	  Polynomial Transformability of Problems in Class NP<br><br>
28. 	  Definition of NP-Complete and the SATISFIABILITY Problem<br><br>
29. 	  The Six Basic NP-Complete Problems and the NP-Completeness Proof for 3SAT<br><br>
30. 	  NP-Completeness Proofs for 3DM, VC, CLIQUE, HC, and PARTITION<br><br>
31. 	  NP-Completeness Proofs by Restriction: Subgraph Isomorphism (SGI), KNAPSACK, Multiprocessor Scheduling (MS), and Bounded-Degree Spanning Tree (BDST)<br><br>
32. 	  NP-Completeness Proofs by Local Replacement: Sequencing within
  Intervals (SQUINT), and Partition into Triangles (PIT)<br><br>
33. 	  NP-Completeness Proofs by Component Design: Minimum Tardiness
  Sequencing (MINTARD)<br><br>
34. 	  Reasoning About the Complexity of the Subproblems of a Given
  NP-Complete Problem (Example: Graph 3-Colorability)
  
35. 	  Strong-Sense and Weak-Sense NP-Completeness for Number
  Problems<br><br>
36. 	  Extending the Complexity Theory to Search Problems<br><br>
37. 	  Generalizing Polynomial Transformability to Turing Reducibility and the Definition of NP-Hard<br><br>
38. 	  Complements and Optimization Versions of the NP-Complete
  Decision Problems<br><br>
39. 	  Approximation Algorithms for Combinatorial Optimization: Bin Packing Optimization (BINPACKO), Traveling Salesman (Restricted) Optimization (TSRO), etc.<br><br>
40. 	  Nonapproximable and Easily Approximable NP-Hard Optimization Problems: Graph Coloring Optimization Problem (GRAPHCOLO), Knapsack Optimization Problem (KNAPSACKO), etc.<br><br>
41. 	  The Classes NPI, co-NP, PNP and NPNP of Problems and
  the Class #P of Enumeration Problems<br><br>
42. 	  Storage Considerations: The Classes PSPACE, PSPACE-Complete, and PSPACE-hard<br><br>
PART 4:  Random Graphs<br><br>
43. 	  Random Graphs: An Introduction<br><br>
44. 	  The Degree Sequence and Polynomial-Time Graph Isomorphism for Random Graphs<br><br>
</div>
  <div id=update_bar> 
   <p align="center">
    <font size="-1">
     Compiled: Sun 08 Aug 2021 12:53:03 AM EDT

    </font>
   </p>
  </div>    
 </body>
</html>
